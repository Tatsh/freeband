#include <stdlib.h>
#include <math.h>
#include "SDL/SDL.h"
#include "SDL/SDL_image.h"
#include "SDL/SDL_opengl.h"
#include "SDL/SDL_ttf.h"

#define SELECTBLENDSRC  0.30
#define SELECTBLENDDEST 0.60

/* This is by NO MEANS final code! This is test code to generate the main menu of Freeband. */

int new_round(double x)
{
  return (int)(x + 0.5);
}

int nextpoweroftwo(int x)
{
  double logbase2 = log(x) / log(2);
  return new_round(pow(2,ceil(logbase2)));
}

char fontpath[] = "crillee.ttf";
void SDL_GL_RenderText(char *text, TTF_Font *font, SDL_Color color, SDL_Rect *location)
{
  SDL_Surface *initial;
  SDL_Surface *intermediary;
  SDL_Rect rect;
  int w,h;
  int texture;
  
  /* Use SDL_TTF to render our text */
  initial = TTF_RenderText_Blended(font, text, color);
  
  /* Convert the rendered text to a known format */
/*  w = nextpoweroftwo(initial->w);
  h = nextpoweroftwo(initial->h); */
}

int showMainMenuOptions()
{
  SDL_Color color;
  SDL_Rect position;
  /* Load font */
  TTF_Font* font;
  if(!(font = TTF_OpenFont(fontpath, 112)))
  {
    printf("Error loading font: %s", TTF_GetError());
    return 1;
  }
}

int loadBG()
{
  GLuint texture;     /* This is a handle to our texture object */
  SDL_Surface *surface; /* This surface will tell us the details of the image */
  GLenum texture_format;
  GLint nOfColors;

  if ((surface = IMG_Load_RW(SDL_RWFromFile("bg.png", "rb"), 1)))
  { 

    /* Check that the image's width is a power of 2 */
    if ((surface->w & (surface->w - 1)) != 0)
    {
      printf("warning: image.png's width is not a power of 2\n");
    }

    /* Also check if the height is a power of 2 */
    if ((surface->h & (surface->h - 1)) != 0)
    {
      printf("warning: image.png's height is not a power of 2\n");
    }
 
    // get the number of channels in the SDL surface
    nOfColors = surface->format->BytesPerPixel;
    if (nOfColors == 4)     // contains an alpha channel
    {
      if (surface->format->Rmask == 0x000000ff)
        texture_format = GL_RGBA;
      else
        texture_format = GL_BGRA;
    }
    else if (nOfColors == 3)     // no alpha channel
    {
      if (surface->format->Rmask == 0x000000ff)
        texture_format = GL_RGB;
      else
        texture_format = GL_BGR;
    } 
    else
    {
      printf("warning: the image is not truecolor..  this will probably break\n");
      return 1;
    }

    glGenTextures(1, &texture);
 
  // Bind the texture object
    glBindTexture(GL_TEXTURE_2D, texture);
 
  // Set the texture's stretching properties
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 
  // Edit the texture object's image data using the information SDL_Surface gives us
    glTexImage2D(GL_TEXTURE_2D, 0, nOfColors, surface->w, surface->h, 0,
                 texture_format, GL_UNSIGNED_BYTE, surface->pixels);
  } 
  else
  {
    printf("SDL could not load image.png: %s\n", SDL_GetError());
    SDL_Quit();
    return 1;
  }
 
// Free the SDL_Surface only if it was successfully created
  if (surface)
  {
    SDL_FreeSurface(surface);
  }

  // Bind the texture to which subsequent calls refer to
  glBindTexture(GL_TEXTURE_2D, texture);
 
  glBegin(GL_QUADS);
  /* For flat objects, glTexCoord3i is ALWAYS (0, 0), (1, 0), (1, 1), (0, 1) consecutively when in this order (TL, TR, BR, BL) */
  glTexCoord2i(0, 0); glVertex2i(0, 0); // Top-left vertex (corner)
  glTexCoord2i(1, 0); glVertex2i(800, 0); // Top-right vertex
  glTexCoord2i(1, 1); glVertex2i(800, 600); // Bottom-right vertex (corner)
  glTexCoord2i(0, 1); glVertex2i(0, 600); // Bottom-left vertex (x offset, same y offset as above)
  glEnd();

  SDL_GL_SwapBuffers();
  
  glDeleteTextures(1, &texture);
  return 0;
}

int loadLogo()
{
  GLuint texture;     // This is a handle to our texture object
  SDL_Surface *surface; // This surface will tell us the details of the image
  GLenum texture_format;
  GLint nOfColors;
  
  if ((surface = IMG_Load_RW(SDL_RWFromFile("logo.png", "rb"), 1)))
  { 
 
  // Check that the image's width is a power of 2
    if ( (surface->w & (surface->w - 1)) != 0 ) {
      printf("warning: image.png's width is not a power of 2\n");
    }
  
  // Also check if the height is a power of 2
    if ( (surface->h & (surface->h - 1)) != 0 ) {
      printf("warning: image.png's height is not a power of 2\n");
    }
 
        // get the number of channels in the SDL surface
    nOfColors = surface->format->BytesPerPixel;
    if (nOfColors == 4)     // contains an alpha channel
    {
      if (surface->format->Rmask == 0x000000ff)
        texture_format = GL_RGBA;
      else
        texture_format = GL_BGRA;
    }
    else if (nOfColors == 3)     // no alpha channel
    {
      if (surface->format->Rmask == 0x000000ff)
        texture_format = GL_RGB;
      else
        texture_format = GL_BGR;
    } 
    else
    {
      printf("warning: the image is not truecolor..  this will probably break\n");
      return 1;
    }

    glGenTextures(1, &texture);
 
  // Bind the texture object
    glBindTexture(GL_TEXTURE_2D, texture);
 
  // Set the texture's stretching properties
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 
  // Edit the texture object's image data using the information SDL_Surface gives us
    glTexImage2D(GL_TEXTURE_2D, 0, nOfColors, surface->w, surface->h, 0,
                 texture_format, GL_UNSIGNED_BYTE, surface->pixels);
  } 
  else {
    printf("SDL could not load image.png: %s\n", SDL_GetError());
    SDL_Quit();
    return 1;
  }
 
// Free the SDL_Surface only if it was successfully created
  if (surface)
  {
    SDL_FreeSurface(surface);
  }

  // Bind the texture to which subsequent calls refer to
  glBindTexture(GL_TEXTURE_2D, texture);
 
  glBegin(GL_QUADS);
    // For flat objects, glTexCoord3i is ALWAYS (0, 0), (1, 0), (1, 1), (0, 1) consecutively when in this order
  glTexCoord2i(0, 0); glVertex2i(10+82, 10+82); // Top-left vertex (corner); 82 pixels is the offset away from top-corner
  glTexCoord2i(1, 0); glVertex2i(638+82, 10+82); // Top-right vertex
  glTexCoord2i(1, 1); glVertex2i(638+82, 245+82); // Bottom-right vertex (corner)
  glTexCoord2i(0, 1); glVertex2i(10+82, 245+82); // Bottom-left vertex (x offset, same y offset as above)
  glEnd();

  SDL_GL_SwapBuffers();
  
  glDeleteTextures(1, &texture);
  return 0;
}

int loadSelector()
{
  GLuint texture;     // This is a handle to our texture object
  SDL_Surface *surface; // This surface will tell us the details of the image
  GLenum texture_format;
  GLint nOfColors;
  
  char *image = "selector.png";
  
  if ((surface = IMG_Load_RW(SDL_RWFromFile(image, "rb"), 1)))
  { 
  // Check that the image's width is a power of 2
    if ((surface->w & (surface->w - 1)) != 0)
    {
      printf("warning: %s's width is not a power of 2\n", image);
    }

  // Also check if the height is a power of 2
    if ((surface->h & (surface->h - 1)) != 0)
    {
      printf("warning: %s's width is not a power of 2\n", image);
    }

    // get the number of channels in the SDL surface
    nOfColors = surface->format->BytesPerPixel;
    if (nOfColors == 4)     // contains an alpha channel
    {
      if (surface->format->Rmask == 0x000000ff)
        texture_format = GL_RGBA;
      else
        texture_format = GL_BGRA;
    }
    else if (nOfColors == 3)     // no alpha channel
    {
      if (surface->format->Rmask == 0x000000ff)
        texture_format = GL_RGB;
      else
        texture_format = GL_BGR;
    }
    else
    {
      printf("warning: the image is not truecolor..  this will probably break\n");
      return 1;
    }

  glGenTextures(1, &texture);

  // Bind the texture object
  glBindTexture(GL_TEXTURE_2D, texture);

  // Set the texture's stretching properties
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

  // Edit the texture object's image data using the information SDL_Surface gives us
  glTexImage2D(GL_TEXTURE_2D, 0, nOfColors, surface->w, surface->h, 0, texture_format, GL_UNSIGNED_BYTE, surface->pixels);
  }
  else
  {
    printf("SDL could not load image.png: %s\n", SDL_GetError());
    SDL_Quit();
    return 1;
  }

  // Free the SDL_Surface only if it was successfully created
  if (surface)
  {
    SDL_FreeSurface(surface);
  }

  // Bind the texture to which subsequent calls refer to
  glBindTexture(GL_TEXTURE_2D, texture);
  glColor4f(1.0, 1.0, 1.0, SELECTBLENDSRC); // Set alpha to SELECTBLENDSRC but keep all other colours the same, before loop

  glBegin(GL_QUADS);
    glColor4f(1.0f, 1.0f, 1.0f, SELECTBLENDSRC);
    // For flat objects, glTexCoord2i is ALWAYS (0, 0), (1, 0), (1, 1), (0, 1) consecutively when in this order
    glTexCoord2i(0, 0); glVertex2i(425, 300); // Top-left vertex (top-left position away from top-left part of screen)
    glTexCoord2i(1, 0); glVertex2i(340+425, 300); // Top-right vertex
    glTexCoord2i(1, 1); glVertex2i(340+425, 360); // Bottom-right vertex
    glTexCoord2i(0, 1); glVertex2i(425, 360); // Bottom-left vertex (x offset, same y offset as above)
  glEnd();
  
  SDL_GL_SwapBuffers();
  glDeleteTextures(1, &texture);
  return 0;
}

int main()
{
  /* Test SDL video */
  if (SDL_Init(SDL_INIT_VIDEO) != 0) {
    printf("Unable to initialise SDL: %s\n", SDL_GetError());
    return 1;
  }
  
  /* Test SDL_ttf */
  if (TTF_Init() == -1) 
  {
    printf("Unable to initialize SDL_ttf: %s\n", TTF_GetError());
    return 1;
  }
  
  /* Enable SDL OpenGL Double-buffering */
  SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
  
  /* Set window 800x600 with 24-bit colours, with OpenGL enabled */
  SDL_Surface *screen;
  screen = SDL_SetVideoMode(800, 600, 24, SDL_OPENGL);
  if (screen == NULL)
  {
    printf("Unable to set video mode: %s\n", SDL_GetError());
    return 1;
  }
  
  /* Set window title and icon title */
  SDL_WM_SetCaption("Freeband", "Freeband");
  
  /* OpenGL functions */
  glEnable(GL_TEXTURE_2D);               /* Enable Texture mapping */
  glEnable(GL_BLEND);                    /* Enable Alpha channel mapping */
  glClearColor(0.0f, 0.0f, 0.0f, 0.0f); /* Black background */
  glViewport(0, 0, 800, 600);
  glClear(GL_COLOR_BUFFER_BIT);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();                     /* Reset the current matrix */
  glOrtho(0.0f, 800, 600, 0.0f, -1.0f, 1.0f);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);

  loadBG();
  loadLogo();
  loadSelector();
  showMainMenuOptions();

  SDL_Event event;
  int running = 1;

  /* Main loop to keep window running */
  while(running) {
    while(SDL_PollEvent(&event)) {
      switch(event.type){
        // End loop if user hits ESC or closes the window
        case SDL_KEYDOWN:
          if (event.key.keysym.sym == SDLK_ESCAPE)
            running = 0;
            break;
        case SDL_QUIT:
          running = 0;
          break;
      }
    }
  }

  return 0;
}
