TIPS FROM TAU (from forum):
I've attempted to make a general purpose rythm-action game engine from scratch. This project has been restarted, literally, fourteen times (let's just say I'm a perfectionist). Protips:

Definitely do it in C. No matter what anyone else says, C++ is far too complicated, and tries to be everytihng to everybody and falls flat. If I want to do large-scale OO shit, I'll use C# or Java. If I want to do high-performance low-level code, I'll write it in C but use an OO-ish design where it suits my purposes. C++ is just neither here nor there. It has neither reflection nor attributes, and doing full-blown OO without those is fucking painful.

BTW, I'm a highly skilled C++ developer, and I write C++ for a living. I have heard of the STL and Boost, and I use both extensively in my work. Templates and operator overloading are awesome, but the rest of it is just not worth the headache.

Lua for animations... may or may not be a good idea. It works if you use it declaratively, but then using a procedural language declaratively can be a bit weird. If you're going to use it procedurally, you'll probably end up with something like scene graph -> Lua -> renderer. This will be a horrid, horrid mess of glue code, it's going to be a really sucky language for stuffing vertex buffers with, and you'll have so many boxing and unboxing operations going on every frame that it'll thrash a multi-GHz CPU to a crawl doing something that in all honesty shouldn't even make a dent.

I'd save myself the headache and do it differently, if I were you. The design I've come up with is to export "property pages" for all scene graph nodes (i.e. a strongly typed container of key -> value pairs. I dunno what level to pitch this to you at, but I'll assume you know what you're doing). Each scene has a list of signals, e.g. "\_enter", "\_exit", "scroll_up", "scroll_down", "song_accept", etc. For each signal, there is a list of tweens. Each tween is a list of (property, start_time, start_value, end_time, end_value) tuples. Add an interpolation scheme (linear, quadratic etc) as well if you want to be really flash. Obviously you can only vary floating-point properties, but if you give every sprite the following set of properties (x,y,z,r,g,b,a,u,v,centre_of_rotation_x,centre_of_rotation_y,angle) then this simple mechanism is powerful enough to express almost any animation you might want to code up. Everything else can be manually implemented in C: don't bust your ass trying to cover one or two awkward corner cases when something much simpler will work 90% of the time. Have it load a DLL for each skin if you're that keen.

Tile your textures, kinda like IIDX does it. If you want this to run fast on old computers, the key is to keep your graphics card's pipeline full. Rebinding textures every time you blit another sprite to the screen might slow things down. Pack as much stuff as you can into 1024x1024 textures, and draw from subsets of those; anything that came out after the Voodoo 3 should support textures of that size.

Write an immediate mode rendering abstraction layer. Make sure you use OpenGL properly (i.e. no glBegin/glEnd pairs for fuck's sake. If you don't know about VBOs, go look them up. Look at Direct3D to see what a good 3D API should look like. Sorry if that offends your open-source cross-platform sensibilities, but it's true). This will require a lot of extensions, and as far as Windows is concerned, Intel is fucking horribly lazy at supporting even the most fundamental of extensions (you'll get multitexture, don't expect anything else though...) ... so you'll have to abstract that away, cuz you're gonna be using Direct3D under Windows. Ever notice that some games support OpenGL AND Direct3D under Windows, but none are pure OpenGL? Intel's useless OpenGL support is the reason why.

For extra brownie points, go look up DirectKS and WASAPI. DirectKS is WinXP only, WASAPI is Vista and above. Both APIs let you completely take over the sound card to deliver extremely low-latency keysounding. IIDX AC doesn't use these, but I really wish it did. Anyway, both of these require you to write your own real time mixer. Daunting as that might sound, it's not that hard; offline sample rate conversion in your audio loader is probably the hardest bit. Leave it out of your first cut, because it takes ages to implement, but you should try implementing it at some point, because I've put together a functional IIDX BMS player with a custom realtime ALSA backend under Linux, and hooked it up to a CRT display running at 100Hz. The gameplay was ... well, it completely blew IIDX CS out of the water, to say NOTHING of AC.

I'll probably resume my project at some point, when I have the time to do so, but those are some of the lessons I learned along the way, and I hope you find some of them useful. I wish you every success in your endeavour.
