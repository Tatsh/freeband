#include "../freeband.h"
#include "../graphics/graphics.h"
#include "instruments.h"
#include "main.h"

char instCanvas[] = "GameData/themes/default/screenInstruments/canvas.png";
char selectedGradient[] = "GameData/themes/default/screenInstruments/selectedgrad.png";

/* Negative is to the left, positive is to the right when horizontal (x)
   Negative is to the top, positive is to the bottom when vertical (y)
   Negative is to the outside, positive is going inside (z)
   Order of corners: top-left, bottom-left, bottom-right, top-right */
GLfloat instCanvasX[] = { 0.1f, 0.1f, 1.2f, 1.2f };
GLfloat instCanvasY[] = { -0.4f, 0.6f, 0.6f, -0.4 };
GLfloat selectedGradientX[] = { 0.12f, 0.12f, 1.18f, 1.18f }; /* This places it underneath 'GUITAR' */
GLfloat selectedGradientY[] = { -0.35f, -0.15f, -0.15f, -0.35f };
GLfloat selectedGradientY_reset[] = { -0.35f, -0.15f, -0.15f, -0.35f };

GLfloat text_GuitarX[] = { 0.3f, 0.3f, 1.0f, 1.0f }; /* Guitar selector's default position */
GLfloat text_GuitarY[] = { -0.35f, -0.15f, -0.15f, -0.35f }; /* Use this as basis to calculate the other Y coordinates */
GLfloat text_BassX[] = { 0.4f, 0.4f, 0.9f, 0.9f };
GLfloat text_BassY[4];
GLfloat text_DrumsX[] = { 0.35f, 0.35f, 0.97f, 0.97f };
GLfloat text_DrumsY[4];
GLfloat text_VocalsX[] = { 0.29f, 0.29f, 1.03f, 1.03f };
GLfloat text_VocalsY[4];

GLfloat text_GuitarX_hl[4];
GLfloat text_GuitarY_hl[4];
GLfloat text_BassX_hl[4];
GLfloat text_BassY_hl[4];
GLfloat text_DrumsX_hl[4];
GLfloat text_DrumsY_hl[4];
GLfloat text_VocalsX_hl[4];
GLfloat text_VocalsY_hl[4];

GLfloat text_SelectInstrumentX[] = { -0.9f, -0.85f, 0.85f, 0.8f }; /* Crillee is italic on its own, this makes it appear not italic */
GLfloat text_SelectInstrumentY[] = { -1.1f, -0.7f, -0.7f, -1.1f };

GLfloat rotationSpeed = 0.0f;

GLuint instSelection = 0; /* Guitar */

tInstrument instrument;

GLvoid handleInstrumentsMenu() {
  
  return;
}

GLvoid setInstrumentsMenuState_1P(GLuint instSelection) {
  GLuint i;
  GLfloat tempX[4], tempY[4];
  
  switch(instSelection) {
    case 0:  /* Guitar */
      instrument.guitar = true;
      instrument.bass = false;
      instrument.drums = false;
      instrument.vocals = false;
      for ( i = 0; i < 4; i++ ) { /* Highlight */
        text_VocalsX_hl[i] = offscreenVertexXY[i]; /* From down arrow */
        text_BassX_hl[i] = offscreenVertexXY[i]; /* From up arrow */
        tempX[i] = text_GuitarX[i];
        tempY[i] = text_GuitarY[i];
        text_GuitarX_hl[i] = tempX[i];
        text_GuitarY_hl[i] = tempY[i];
      }
#ifdef __DEBUG__
      fprintf(stdout, "Selected Guitar gameplay.\n");
#endif
      break;

    case 1: /* Bass */
      instrument.guitar = false;
      instrument.bass = true;
      instrument.drums = false;
      instrument.vocals = false;
      for ( i = 0; i < 4; i++ ) {
        text_GuitarX_hl[i] = offscreenVertexXY[i];
        text_DrumsX_hl[i] = offscreenVertexXY[i];
        tempX[i] = text_BassX[i];
        tempY[i] = text_BassY[i];
        text_BassX_hl[i] = tempX[i];
        text_BassY_hl[i] = tempY[i];
      }
#ifdef __DEBUG__
      fprintf(stdout, "Selected Bass gameplay.\n");
#endif
      break;

    case 2: /* Drums */
      instrument.guitar = false;
      instrument.bass = false;
      instrument.drums = true;
      instrument.vocals = false;
      for ( i = 0; i < 4; i++ ) {
        text_BassX_hl[i] = offscreenVertexXY[i];
        text_VocalsX_hl[i] = offscreenVertexXY[i];
        tempX[i] = text_DrumsX[i];
        tempY[i] = text_DrumsY[i];
        text_DrumsX_hl[i] = tempX[i];
        text_DrumsY_hl[i] = tempY[i];
      }
#ifdef __DEBUG__
      fprintf(stdout, "Selected Drums gameplay.\n");
#endif
      break;

    case 3: /* Vocals */
      instrument.guitar = false;
      instrument.bass = false;
      instrument.drums = false;
      instrument.vocals = true;
      for ( i = 0; i < 4; i++ ) {
        text_DrumsX_hl[i] = offscreenVertexXY[i];
        text_GuitarX_hl[i] = offscreenVertexXY[i];
        tempX[i] = text_VocalsX[i];
        tempY[i] = text_VocalsY[i];
        text_VocalsX_hl[i] = tempX[i];
        text_VocalsY_hl[i] = tempY[i];
      }
#ifdef __DEBUG__
      fprintf(stdout, "Selected Vocals gameplay.\n");
#endif
      break;
    
      default:
        break;

  }

  return;
}

GLvoid setInstrumentsImages_1P() {
  if ((texture[0] = loadTexture(bgTexture, 0)) == -1)
    fprintf(stderr, "Unable to load texture: %s.\n", bgTexture);
  
  if ((texture[1] = loadTexture(instCanvas, 1)) == -1)
    fprintf(stderr, "Unable to load texture: %s.\n", instCanvas);
  
  if ((texture[2] = loadTexture(selectedGradient, 2)) == -1)
    fprintf(stderr, "Unable to load texture: %s.\n", selectedGradient);
  
  return;
}

GLvoid setInstrumentsText_1P() {
  TTF_Font *font, *instFont;
  font = TTF_OpenFont(defaultFont, DEFAULT_TEXT_PT); /* 72 seems to be the best size for this font */
  instFont = TTF_OpenFont(bitstreamFont, DEFAULT_TEXT_PT);
  if (!font)
    fprintf(stderr, "SDL_ttf: TTF_OpenFont() response: %s\n", TTF_GetError());
  else if (!instFont)
    fprintf(stderr, "SDL_ttf: TTF_OpenFont() response: %s\n", TTF_GetError());
  else {
    GLuint guitar, bass, drums, vocals;
    GLuint guitarS, bassS, drumsS, vocalsS; /* Selected versions */
    GLuint selectInstrument;
    
    guitar = loadText("GUITAR", instFont, white, 0);
    bass = loadText("BASS", instFont, white, 1);
    drums = loadText("DRUMS", instFont, white, 2);
    vocals = loadText("VOCALS", instFont, white, 3);
    
    guitarS = loadText("GUITAR", instFont, yellow, 4); /* Prepare selected versions */
    bassS = loadText("BASS", instFont, yellow, 5);
    drumsS = loadText("DRUMS", instFont, yellow, 6);
    vocalsS = loadText("VOCALS", instFont, yellow, 7);
    
    selectInstrument = loadText("SELECT INSTRUMENT", font, white, 8);
  }
    
  if (font)
    TTF_CloseFont(font); /* Clean up */
  
  return;
}

GLvoid screenInstrumentsBuffer(GLuint nPlayers) {
  GLuint i;
  
  if (nPlayers < 2) {
    
    /* Generate Y coordinates for text */
    for ( i = 0; i < 4; i++ ) text_BassY[i] = text_GuitarY[i] + 0.23;
    for ( i = 0; i < 4; i++ ) text_DrumsY[i] = text_BassY[i] + 0.23;
    for ( i = 0; i < 4; i++ ) text_VocalsY[i] = text_DrumsY[i] + 0.23;
  
    /* Set guitar to be highlighted by default */
    for ( i = 0; i < 4; i++ ) {
      text_GuitarX_hl[i] = text_GuitarX[i];
      text_GuitarY_hl[i] = text_GuitarY[i];
    }

    
    /* Set all highlight versions off screen, except for first option since that is highlighted by default */
    for ( i = 0; i < 4; i++ ) {
      text_BassX_hl[i] = offscreenVertexXY[i];
      text_BassY_hl[i] = offscreenVertexXY[i];
      text_DrumsX_hl[i] = offscreenVertexXY[i];
      text_DrumsY_hl[i] = offscreenVertexXY[i];
      text_VocalsX_hl[i] = offscreenVertexXY[i];
      text_VocalsY_hl[i] = offscreenVertexXY[i];
    }

    setInstrumentsImages_1P();
    setInstrumentsText_1P();
 
  }
  else
    fprintf(stdout, "Multiplayer not implemented yet.\n");
#ifdef __DEBUG__
  fprintf(stdout, "Loading textures of screenInstruments complete.\n");
#endif
  
  return;
}

GLvoid screenInstruments(GLuint nPlayers) {
  
  glBindTexture( GL_TEXTURE_2D, texture[0] );
  positionTexture(fillBGVertexX, fillBGVertexY, defVertexZ, defaultAlpha);
  
  glBindTexture( GL_TEXTURE_2D, texture[1] );
  positionTexture(instCanvasX, instCanvasY, defVertexZ, defaultAlpha);
  
  glBindTexture( GL_TEXTURE_2D, texture[2] );
  positionTexture(selectedGradientX, selectedGradientY, defVertexZ, defaultAlpha);
  
  /* Text elements */
  glBindTexture( GL_TEXTURE_2D, text[0] );
  positionTexture(text_GuitarX, text_GuitarY, defVertexZ, defaultAlpha);

  glBindTexture( GL_TEXTURE_2D, text[1] );
  positionTexture(text_BassX, text_BassY, defVertexZ, defaultAlpha);
  
  glBindTexture( GL_TEXTURE_2D, text[2] );
  positionTexture(text_DrumsX, text_DrumsY, defVertexZ, defaultAlpha);
  
  glBindTexture( GL_TEXTURE_2D, text[3] );
  positionTexture(text_VocalsX, text_VocalsY, defVertexZ, defaultAlpha);
  
  glBindTexture( GL_TEXTURE_2D, text[4] );
  positionTexture(text_GuitarX_hl, text_GuitarY_hl, defVertexZ, defaultAlpha);
  
  glBindTexture( GL_TEXTURE_2D, text[5] );
  positionTexture(text_BassX_hl, text_BassY_hl, defVertexZ, defaultAlpha);
  
  glBindTexture( GL_TEXTURE_2D, text[6] );
  positionTexture(text_DrumsX_hl, text_DrumsY_hl, defVertexZ, defaultAlpha);
  
  glBindTexture( GL_TEXTURE_2D, text[7] );
  positionTexture(text_VocalsX_hl, text_VocalsY_hl, defVertexZ, defaultAlpha);
  
  glBindTexture( GL_TEXTURE_2D, text[8] ); /* Top screen title */
  positionTexture(text_SelectInstrumentX, text_SelectInstrumentY, defVertexZ, defaultAlpha);

  switch (instSelection) {
    case 0:
      glTranslatef(-0.15f, -0.1f, 2.0f);
      glRotatef( 110.0f, -0.05f, 0.0f, 0.0f );
      glRotatef( rotationSpeed, 0.0f, 0.0f, 0.05f );
      glPushMatrix();
      glBindTexture( GL_TEXTURE_2D, texture[0] );
      gluCylinder( quadratic, 0.05f, 0.05f, 0.1f, 32, 32 );
      glPopMatrix();
      break;
      
    case 1:
      glTranslatef(-0.15f, -0.1f, 2.0f);
      glRotatef( 110.0f, -0.05f, 0.0f, 0.0f );
      glRotatef( rotationSpeed, 0.0f, 0.0f, 0.05f );
      glPushMatrix();
      glBindTexture( GL_TEXTURE_2D, texture[0] );
      gluCylinder( quadratic, 0.05f, 0.0f, 0.1f, 32, 32 );
      glPopMatrix();
      break;
      
    case 2:
      glTranslatef(-0.15f, -0.1f, 2.0f);
      glRotatef( 110.0f, -0.05f, 0.0f, 0.0f );
      glRotatef( rotationSpeed, 0.0f, 0.0f, 0.05f );
      glPushMatrix();
      glBindTexture( GL_TEXTURE_2D, texture[0] );
      gluCylinder( quadratic, 0.0f, 0.05f, 0.1f, 32, 32 );
      glPopMatrix();
      break;
      
    case 3:
      glTranslatef(-0.15f, -0.05f, 2.0f);
      glRotatef( 110.0f, -0.05f, 0.0f, 0.0f );
      glRotatef( rotationSpeed, 0.0f, 0.0f, 0.05f );
      glPushMatrix();
      glBindTexture( GL_TEXTURE_2D, texture[1] );
      gluCylinder( quadratic, 0.05f, 0.05f, 0.1f, 32, 32 );
      glPopMatrix();
      break;
      
    default:
      break;
  }

  if (rotationSpeed == 360)
    rotationSpeed = 0;
  else
    rotationSpeed += 0.5f;
}
