#include "../freeband.h"
#include "../audio/audio.h"
#include "../screens/difficulty.h"
#include "../screens/game.h"
#include "../screens/instruments.h"
#include "../screens/main.h"
#include "../screens/songs.h"
#include "graphics.h"

bool loading;

char crilleePath[] = "GameData/themes/default/global/crillee.ttf";
char bitstreamPath[] = "GameData/themes/default/global/bitstream-vera-sans-bold.ttf";
char bitstreamMonoBoldPath[] = "GameData/themes/default/global/bitstream-vera-mono-bold.ttf";
char freeSansPath[] = "GameData/themes/default/global/freesans.ttf";
char freeSansBoldPath[] = "GameData/themes/default/global/freesans-bold.ttf";

GLfloat buttonColour_green[] = { 0.137f, 0.585, 0.0f, 1.0f };
GLfloat buttonColour_red[] = { 1.0f, 0.0f, 0.0f, 1.0f };
GLfloat buttonColour_yellow[] = { 1.0f, 1.0f, 0.0, 1.0f };
GLfloat buttonColour_blue[] = { 0.059f, 0.0f, 0.71f, 1.0f};
GLfloat buttonColour_orange[] = { 1.0f, 0.647, 0.114, 1.0f };

GLfloat colour_blue_7CA4F6[] = { 0.484f, 0.643f, 0.964f, 1.0f }; /* approximations */
GLfloat colour_yellow_F0FF07[] = { 0.941, 1.0f, 0.027f, 1.0f };

/* Negative is to the left, positive is to the right when horizontal (x)
   Negative is to the top, positive is to the bottom when vertical (y)
   Negative is to the outside, positive is going inside (z)
   Order of corners: top-left, bottom-left, bottom-right, top-right */
GLfloat defVertexZ[] = { 0.0f, 0.0f, 0.0f, 0.0f };    /* All flat facing user textures use this z value */
GLfloat fillBGVertexX[] = {  -1.4f, -1.4f,  1.4f,   1.4f }; /* Fill entire background position */
GLfloat fillBGVertexY[] = { -1.04f, 1.04f, 1.04f, -1.04f };
GLfloat offscreenVertexXY[] = { 0.0f, 0.0f, 0.0f, 0.0f };
GLfloat z = -2.5f;

GLUquadricObj *quadratic;

SDL_Color blue_7CA4F6;
SDL_Color yellow;
SDL_Color white;

bool initGL() {
  /* OpenGL functions */
  glEnable(GL_TEXTURE_2D);                /* Enable texture mapping */
  glShadeModel(GL_SMOOTH);                /* Enable smooth shading */
  glEnable(GL_BLEND);                     /* Enable Alpha channel mapping */
  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);   /* Black background */
  glViewport(0, 0, 800, 600);
  glClear(GL_COLOR_BUFFER_BIT);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();                       /* Reset the current matrix */
  glOrtho(0.0f, 800, 600, 0.0f, -1.0f, 1.0f);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glClearDepth(1.0f);                     /* Depth buffer setup */
  glEnable(GL_DEPTH_TEST);                /* Enables depth testing */
  glDepthFunc(GL_LEQUAL);                 /* Type of depth testing */

  quadratic = gluNewQuadric();
  /* Create Smooth Normals */
  gluQuadricNormals(quadratic, GLU_SMOOTH);
  /* Create Texture Coords */
  gluQuadricTexture(quadratic, GL_TRUE);

  return true;
}

bool resizeWindow(GLuint width, GLuint height) {
  GLfloat ratio; /* Height/width ratio */

  if (height == 0)  /* Protect against a divide by zero */
    height = 1;

  ratio = (GLfloat)width / (GLfloat)height;
  glViewport(0, 0, (GLsizei)width, (GLsizei)height ); /* Setup our viewport. */
  glMatrixMode(GL_PROJECTION); /* change to the projection matrix and set our viewing volume. */
  glLoadIdentity();
  gluPerspective( 45.0f, ratio, 0.1f, 100.0f ); /* Set our perspective */
  glMatrixMode(GL_MODELVIEW); /* Make sure we're chaning the model view and not the projection */
  glLoadIdentity(); /* Reset the view */

  return true;
}

GLfloat centreAt(GLfloat xyz, GLfloat width) {
  GLfloat offset;

  offset = (width / 2.0f) - xyz;

  if ((offset < 0.0f && xyz > 0.0f) || (width >= (xyz * 2)))
    return -offset;
  else
    return offset;
}

/* These scaling functions have nothing to do with below loading functions
   Use only when you know the image's original dimensions; this helps with theming; more functionality later
   This is also useful for text, specify any height or width (in pixels) and get the correct corresponding width or height for an
     texture */
GLfloat scaleTextureHeight(GLuint pWidth, GLuint pHeight, GLfloat destWidth) {
  GLfloat destHeight;
  
  destHeight = ((GLfloat)pHeight / (GLfloat)pWidth) * destWidth;
  
  return destWidth;
}

GLfloat scaleTextureWidth(GLuint pWidth, GLuint pHeight, GLfloat destHeight) {
  GLfloat destWidth;
  
  destWidth = ((GLfloat)pWidth / (GLfloat)pHeight) * destHeight;
  
  return destWidth;
}

GLuint loadText(char *input, TTF_Font *font, SDL_Color color, GLuint index) {
  SDL_Surface *textTexture;
  
  /* Use SDL_ttf to render text */
  if ( (textTexture = TTF_RenderUTF8_Blended(font, input, color)) ) {
    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
    glGenTextures(1, &text[index]);
    glBindTexture(GL_TEXTURE_2D, text[index]);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

    gluBuild2DMipmaps(GL_TEXTURE_2D, 4, textTexture->w, textTexture->h, GL_RGBA, GL_UNSIGNED_BYTE, textTexture->pixels);
  }
  else {
    fprintf(stderr, "SDL_ttf could render %s.\n%s\n", input, TTF_GetError());
    quitGame(1);
  }

#ifdef __DEBUG__
  /* Print good AR, for theming purposes only */
  GLfloat ar, arinv;
  ar = (GLfloat)textTexture->w / (GLfloat)textTexture->h;
  arinv = 1.000f / ar;
  fprintf(stdout,
          "Aspect ratios for text '%s': %dx%d pixels, %.3f:1.000, 1.000:%.3f\n",
          input, textTexture->w, textTexture->h, ar, arinv);
#endif
  
  /* Clean up */
  if (textTexture)
    SDL_FreeSurface(textTexture);
  else
    return -1;
  
  return text[index];
}

GLuint loadTexture(const char *filename, GLuint index) {
  SDL_Surface *surface; /* Store information here, size, etc */
  
  if ((surface = IMG_Load(filename))) {
    /* GLU will convert textures to POT before sending to GL */
    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
    glGenTextures(1, &texture[index]);
    glBindTexture(GL_TEXTURE_2D, texture[index]);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_LINEAR);
    SDL_PixelFormat *format = surface->format;

    if (format->Amask) /* Check for alpha channel */
      gluBuild2DMipmaps(GL_TEXTURE_2D, 4, surface->w, surface->h, GL_RGBA, GL_UNSIGNED_BYTE, surface->pixels);
    else
      gluBuild2DMipmaps(GL_TEXTURE_2D, 3, surface->w, surface->h, GL_RGB, GL_UNSIGNED_BYTE, surface->pixels);

#ifdef __DEBUG__
    /* Print good AR */
    GLfloat ar, arinv;
    ar = (GLfloat)surface->w / (GLfloat)surface->h;
    arinv = 1.000f / ar;
    fprintf(stdout,
            "Aspect ratios for image '%s': %dx%d pixels, %.3f:1.000, 1.000:%.3f\n",
            filename, surface->w, surface->h, ar, arinv);
#endif
  }
  else {
    fprintf(stderr, "SDL could not load %s.\n%s\n", filename, SDL_GetError());
    quitGame(1);
  }
 
  /* Free the SDL_Surface only if it was successfully created */
  if (surface)
    SDL_FreeSurface(surface);
  else
    return -1;

  return texture[index];
}

GLvoid clearScreen() {
  glDeleteTextures(MAX_IMAGES, &texture[0]); /* Clean up old screen */
  glDeleteTextures(MAX_TEXT, &text[0]);
  return;
}

GLvoid getFont(GLuint font) {

  switch (font) {
    case 0: /* Crillee */
      crillee = TTF_OpenFont(crilleePath, DEFAULT_TEXT_PT);
      if (!crillee) {
        fprintf(stderr, "Could not load font Crillee: %s\n", TTF_GetError());
        quitGame(1);
      }
      break;

      case 1: /* Bitstream Vera Sans */
        bitstream = TTF_OpenFont(bitstreamPath, DEFAULT_TEXT_PT);
        if (!bitstream) {
          fprintf(stderr, "Could not load font Bitstream Vera Sans: %s\n", TTF_GetError());
          quitGame(1);
        }
        break;

      case 2: /* Bitstream Vera Mono Bold */
        bitstreamMonoBold = TTF_OpenFont(bitstreamMonoBoldPath, DEFAULT_TEXT_PT);
        if (!bitstreamMonoBold) {
          fprintf(stderr, "Could not load font Bitstream Vera Mono Bold: %s\n", TTF_GetError());
          quitGame(1);
        }
        break;

      case 3: /* FreeSans */
        freeSans = TTF_OpenFont(freeSansPath, DEFAULT_TEXT_PT);
        if (!freeSans) {
          fprintf(stderr, "Could not load font FreeSans: %s\n", TTF_GetError());
          quitGame(1);
        }
        break;

      case 4: /* FreeSans Bold */
        freeSansBold = TTF_OpenFont(freeSansBoldPath, DEFAULT_TEXT_PT);
        if (!freeSans) {
          fprintf(stderr, "Could not load font FreeSans Bold: %s\n", TTF_GetError());
          quitGame(1);
        }
        break;

      default:
        break;
  }

  return;
}

GLvoid positionTexture(GLfloat *vertexX, GLfloat *vertexY, GLfloat *vertexZ) {

  glBegin(GL_QUADS);
    glTexCoord2f( 0.0f, 0.0f ); glVertex3f( vertexX[0], vertexY[0], vertexZ[0] ); /* Top left corner */
    glTexCoord2f( 0.0f, 1.0f ); glVertex3f( vertexX[1], vertexY[1], vertexZ[1] ); /* Bottom left corner */
    glTexCoord2f( 1.0f, 1.0f ); glVertex3f( vertexX[2], vertexY[2], vertexZ[2] ); /* Bottom right corner */
    glTexCoord2f( 1.0f, 0.0f ); glVertex3f( vertexX[3], vertexY[3], vertexZ[3] ); /* Top right corner */
  glEnd();

  return;
}

GLvoid setupColors() {
  blue_7CA4F6.r = 253;
  blue_7CA4F6.g = 166;
  blue_7CA4F6.b = 118;
  
  white.r = 255; /* White */
  white.g = 255;
  white.b = 255;
    
  yellow.r = 7; /* r and b are reversed because we load a BGR space with OpenGL */
  yellow.g = 255;
  yellow.b = 240;
  
  return;
}

GLvoid drawFreeband() {
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); /* Clear the screen and the depth buffer */
  glLoadIdentity();
  glTranslatef(0.0f, 0.0f, z);
  
  glScalef(1, -1, 1); /* Flip framebuffer because of SDL's upside down issue */

  if (loading); /* Do nothing and wait till loading = false */
  else if (currentScreen.mainMenu && !menuQuit) {
    screenMain();
  }
  else if (currentScreen.instruments && !menuQuit)
    screenInstruments(nPlayers);
  else if (currentScreen.songs && !menuQuit)
    screenSongs();
  else if (currentScreen.difficulty && !menuQuit)
    screenDifficulty();
  else if (currentScreen.game && !gamePaused)
    screenGame();

  SDL_GL_SwapBuffers();

  /* Gather our frames per second */
  static GLuint Frames = 0;
  Frames++;
#ifdef __DEBUG__
  static GLuint T0     = 0;
  GLuint t = SDL_GetTicks();
  if (t - T0 >= 5000) {
    GLfloat seconds = (t - T0) / 1000.0;
    GLfloat fps = Frames / seconds;
    printf("%d frames in %.0f seconds = %g FPS\n", Frames, seconds, fps);
    T0 = t;
    Frames = 0;
  }
#endif

  return;
}
